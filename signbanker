#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# Docstrings are in googledoc format.
# [https://github.com/google/styleguide/blob/gh-pages/pyguide.md]
# [http://daouzli.com/blog/docstring.html#googledoc]
# [https://gist.github.com/redlotus/3bc387c2591e3e908c9b63b97b11d24e]
#
# HTML processing is done using MechanicalSoup (rather than the older Mechanize
# module).
#
"""View or modify information in a Signbank.
Usage:
  signbanker [OPTION]...
  signbanker [OPTION]... gloss GLOSS_ID [FIELD VALUE]...
  signbanker [OPTION]... help [COMMAND] [X]...
  signbanker [OPTION]... lexicon [LEXICON_ID]

Options:
  -b,--base=URL          signbank address [default: https://signbank.ling.su.se]
  -h,--help              show this help, or help about COMMAND, then exit
  -l,--login=USER[:PASS] login name (and optional password) for signbank
  -v,--version           display version information and exit

Commands:
  gloss    show or edit the data of individual gloss
  help     show this help, or help about COMMAND, then exit
  lexicon  list available lexicons, or glosses in a given lexicon

TODO (Not yet implemented):
  * Output should be prettier (choice between CSV, TSV and formatted tables)
  * Add docstrings for all functions
  * Keep login & password around for a bit (spawn a daemon that dies after
    some timeout, maybe communicating via named pipes?)
  * When showing gloss, more fields are displayed than one can (presumably)
    modify. Fix this.
  * Default using current login name if no --login option used.
  * Add support for adding / removing multiple-valued field (like 'URL' --
    called 'glossurl-NUM' in the backend)
"""
__title__     = 'signbanker (STS-Signbank)'
__version__   = '0.2.0'                        # https://semver.org/
__author__    = 'zrajm <zrajm@zrajm.org>'
__copyright__ = 'Copyright (C) 2021 zrajm <zrajm@klingonska.org>'
__license__   = 'GPLv2'
__info__      = \
"""License GPLv2: GNU GPL version 2 <https://www.gnu.org/licenses/gpl-2.0.html>.
You are free to share and modify this program, as long as your version use
the same license, and give credit to the original author.

Written by zrajm for the Swedish Signbank <https://signbank.ling.su.se/>,
Sign Language Section, Department of Linguistics, Stockholm university."""

import re
import sys

class SignbankError(Exception): pass
class Signbank:
    """Signbank related stuff."""
    browser = None
    base_url = None
    username = None
    password = None
    urls = {
        'login'        : 'accounts/login/',
        'show_gloss'   : 'dictionary/advanced/gloss/',
        'edit_gloss'   : 'dictionary/update/gloss/',
        'list_glosses' : 'dictionary/advanced/?paginate_by=9999999&dataset=',
        'list_lexicons': 'dictionary/advanced/',
    }
    login_form = 'login'

    def __init__(self, base=None, user=None, password=None):
        if not re.search(r'^\w+://', base):
            base = f'https://{base}'
        self.base_url = base
        self.username = user
        self.password = password

    def page(self, name, xtra=''):
        return f'{self.base_url}/{self.urls[name]}{xtra}'

    def login(self):
        from mechanicalsoup import (LinkNotFoundError, StatefulBrowser)
        self.browser = StatefulBrowser(
            soup_config = { 'features': 'html.parser' }
        )
        if not self.password:
            if not sys.stdin.isatty():
                raise SignbankError(f"Cannot read password from standard input."
                    f"\n    Use '--login=USER:PASS' for password when STDIN is not a terminal.")
            from getpass import getpass
            self.password = getpass(f"{self.username}'s password: ")
        url = self.page('login')
        response = self.open(url)
        form = self.select_form(self.login_form)
        form.set('username', self.username)
        form.set('password', self.password)
        response = self.__fetch(lambda: self.browser.submit_selected())

        # We are now logged in and a login form should NOT be present on the
        # returned page. Therefore we look for the login form, and raise an
        # exception if it can be found.
        try:
            form = self.browser.select_form(f'[name="{self.login_form}"]')
            msg = form.form.select_one('.alert') # get form error message
            if msg:
                msg.button.extract()           # remove HTML close button
                msg = ''.join(msg.stripped_strings)
            raise SignbankError(
                f"Cannot login as user '{self.username}' (Bad username/password?)" +
                (f"\n    Signbank: {msg}" if msg else '')
            )
        except LinkNotFoundError:
            pass

    def select_form(self, form_name):
        from mechanicalsoup import LinkNotFoundError
        try:
            return self.browser.select_form(f'[name="{form_name}"]')
        except LinkNotFoundError as e:
            raise SignbankError(
                f"Cannot find form named '{form_name}' on page " +
                f"'{self.browser.get_url()}'.\n")

    def open(self, *args, **kwargs):
        """Wrapper for MechanicalSoup's browser.open()"""
        return self.__fetch(lambda: self.browser.open(*args, **kwargs))

    def __fetch(self, fetch_func):
        """Wrapper for all MechanicalSoup's methods that return a response."""
        if not self.browser:
            self.login()
        from requests.exceptions import RequestException
        try:
            response = fetch_func()
        except RequestException as e: raise SignbankError(
                f'Cannot load signbank page.\n'
                f'    Error: {type(e).__name__}: {e}')
        if not response.ok:
            raise SignbankError(
                f"Cannot load signbank page '{self.browser.get_url()}'.\n"
                f'    Server response: {response.status_code} - {response.reason}')
        return response

    def get_csrf_token(self):
        """Returns first occurence the CSRF token (string) on a signbank page.

        A CSRF (Cross-Site Request Forgery) token occurs on all pages that have
        (at least one) form which require user privileges. If there are
        multiple forms, the CSRF token have the same value in all of them.

        For a CSRF token are only present if you a) are logged in to the
        signbank and b) on pages with forms that require user privileges (forms
        that update the database content).

        Args:
          response(mechanicalsoup.response): A HTML response with a signbank page.

        Returns:
          string: CSRF token.

        Raises:
          AttributeError: No CSRF token could be found.
        """
        return self.browser.get_current_page().select_one(
            f'input[name="csrfmiddlewaretoken"]'
        ).get('value');

    def list_lexicons(self):
        lexicon_url = self.page('list_lexicons')
        response = self.open(lexicon_url)
        column_name = response.soup.select_one('label[for="id_dataset"]').text
        return [
            ['ID', column_name],
            *map(
                lambda option: [option.get('value'), option.text],
                response.soup.select('select[name="dataset"] option')),
        ]

    def list_glosses(self, lexicon_id):
        """List glosses in lexicon."""
        if not re.search(r'^\d+$', lexicon_id):
            raise SignbankError(f"LEXICON_ID must be numeric (not '{lexicon_id}')")
        def space_cleanup(x):
            return re.sub(r'\s+', ' ', (' '.join(x.stripped_strings)))
        list_url = self.page('list_glosses', lexicon_id)
        response = self.open(list_url)   # FIXME: should be get request(?)
        main_table = response.soup.select_one('main table')
        return [
            ['ID', *map(space_cleanup, main_table.select('thead tr th'))],
            *map(
                lambda row: [row.a['href'].split('/')[-1], *map(space_cleanup, row.select('td'))],
                main_table.select('tbody tr')),
        ]

    def show_gloss(self, gloss_id):
        """Display info of a gloss_id."""
        if not re.search(r'^\d+$', gloss_id):
            raise SignbankError(f"GLOSS_ID must be numeric (not '{gloss_id}')")
        view_url = self.page('show_gloss', gloss_id)
        response = self.open(view_url)
        return map(
            lambda tag: [tag.get('id'), [*tag.contents, ''][0]],
            response.soup.select('div#definition .edit'),
        )

    def edit_gloss(self, gloss_id, fields, values):
        if not re.search(r'^\d+$', gloss_id):
            raise SignbankError(f"GLOSS_ID must be numeric (not '{gloss_id}')")
        view_url = self.page('show_gloss', gloss_id)
        response = self.open(view_url)
        token    = self.get_csrf_token()
        print('Setting:')
        modify_url = self.page('edit_gloss', gloss_id)
        for (field, value) in zip(fields, values):
            print(f"  {field}: '{value}'")
            self.browser.post(
                modify_url,
                data = {
                    'csrfmiddlewaretoken': token,
                    'id': field,
                    'value': value,
                },
            )

def prettify_docopt_error(e):
    from os.path import basename
    from sys import argv
    msg = None
    if type(e).__name__ == 'DocoptExit':       # prettify docopt errors
        # Remove 'usage:' info.
        msg = re.sub(r'(?:^|\s+)usage:.*', '', e.code, flags=re.IGNORECASE | re.DOTALL)
        msg = re.sub(r'-\S+', "Option '\g<0>'", msg) # quote option names
        if not msg:                            # if msg is empty
            msg = 'Bad arguments'
        # For docopt errors, append helpful tip.
        msg += f"\nTry '{__file__} help' for more information."
    return (basename(__file__) + ': ' + (msg or str(e)))

def get_command(args):
    """Return name of command given on command line that is set to True, and which
    has a corresponding to a 'cmd_{command}' function in the code.
    """
    for arg in args:
        if args[arg] == True:
            try: eval(f'cmd_{arg}')
            except NameError: continue
            return arg

################################################################################
##  Command Line Functions

def cmd_gloss(signbank, gloss_id, fields = [], values = []):
    """signbanker [OPTION]... gloss GLOSS_ID [FIELD VALUE]...

    Without FIELD/VALUE pairs, output all fields for given gloss. Each field is
    output on a separate line, with field name first followed whitespace, and
    thereafter field value. (Field names never contain spaces.) If a field
    value is unset, this is shown as '-'.

    With one or more FIELD/VALUE pairs given, these values will be updated in
    the signbank. NOTE: Currently the updating of values is pretty naïve,
    simple single-valued fields work fine, but some fields (like 'URL') have
    multiple values which can be added and deleted separately -- these can
    unfortunately not yet be modified with this tool.)

    """
    if values:                             #   with values
        signbank.edit_gloss(gloss_id, fields, values)
    else:                                  #   without values
        return signbank.show_gloss(gloss_id)

def cmd_help(command = None):
    """signbanker [OPTION]... (help|--help) [COMMAND]

    Witout COMMAND, output a general help message, then exit.

    With COMMAND, output a more detailed help message for the given signbanker
    command, then exit.

    When using the option form (--help, or -h), only the first occurring
    COMMAND (if any) will be considered, all other options and argument will be
    ignored. This allows you to tuck on the '--help' option anywhere on the
    command line to get more information about the current command. The 'help'
    command however, must always occur first on the command line.

    """
    from inspect import cleandoc
    try:
        docstr = eval(f'cmd_{command}.__doc__') if command else __doc__
    except NameError:
        raise SignbankError(
            f"Unknown signbanker command '{command}'" +
            f"\nTry '{__file__} help' to list available commands.")
    docstr = docstr.replace(' [X]...', '')

    print(cleandoc(docstr))
    raise SystemExit(0)

def cmd_lexicon(signbank, lexicon_id = None):
    """signbanker [OPTION]... lexicon [LEXICON_ID]

    Without LEXICON_ID, output list of lexicons found in the signbank. The
    following columns are output:

      * Lexicon ID (use with this command)
      * Lexicon name

    With a LEXICON_ID is specified, list the glosses in that lexicon. The
    following columns are output:

      * Gloss ID (use with 'gloss' command)
      * Lexicon
      * Gloss
      * English gloss
      * Translations
      * Notes
      * Tags

    Output is in a tab-separated format.
    """
    if lexicon_id:                         #   with values
        return signbank.list_glosses(lexicon_id)
    else:
        return signbank.list_lexicons()

################################################################################
##  Main

def main(args):
    # Docopt command line values.
    base_url = args['--base']                  # required
    gloss_id = args['GLOSS_ID']                # optional (string)
    fields   = args['FIELD']                   # optional (list)
    values   = args['VALUE']                   # optional (list)
    (username, password) = map(
        lambda x: x or None,
        [*(args['--login'] or '').split(':', 1), ''][:2],
    )
    # If '--help' option is used, turn this into 'help' command.
    # (Set command to 'help' and copy signbanker command into 'COMMAND' arg.)
    if args['--help']:
        args['COMMAND'] = get_command(args)
        args['help'] = True
    if args['help']:
        cmd_help(args['COMMAND'])

    if args['--version']:
        print(f'{__title__} {__version__}\n{__copyright__}\n{__info__}')
        raise SystemExit(0)

    if not username:
        raise SignbankError("Option '--login=USER[:PASS]' is required")

    signbank = Signbank(base_url, username, password)
    out = [];
    if args['gloss']:                          # 'gloss' subcommand
        out = cmd_gloss(signbank, gloss_id, fields, values)
    elif args['lexicon']:                      # 'lexicon' subcommand
        out = cmd_lexicon(signbank, args['LEXICON_ID'])
    for cols in out:
        print('\t'.join(cols))

################################################################################
## Invoke program

# Which (Debian or pip) package to install when a Python module is missing.
package_name = {
    'docopt':         { 'deb': 'python3-docopt',         'pip': 'docopt' },
    'mechanicalsoup': { 'deb': 'python3-mechanicalsoup', 'pip': 'MechanicalSoup' },
}
if __name__ == '__main__':
    class DocoptExit(Exception): pass          # used if Docopt isn't installed
    try:
        from sys import stderr
        from docopt import (docopt, DocoptExit)
        if __doc__ == None:
            raise SignbankError(
                "Cannot find docstrings " +
                "(Cannot run with Python '-OO' option!)")
        # Parse command line args with docopt and pass them to main().
        main(docopt(
            __doc__.replace('[OPTION]...', '[options]'),
            help = False,
        ))
    except KeyboardInterrupt:
        print('\n*** BREAK: Killed by ^C (SIGINT signal)', file = stderr)
        raise SystemExit(130)
    except (DocoptExit, SignbankError) as e:
        print(prettify_docopt_error(e), file = stderr)
        raise SystemExit(5)
    except ModuleNotFoundError as e:
        print(f"ERROR: Cannot load the required Python module '{e.name}'.\n" + (
            f"To install, run one of following commands (depending on your system):\n\n"
            f"    sudo apt install {package_name[e.name]['deb']}  # (Debian/Ubuntu etc.)\n"
            f"    pip install {package_name[e.name]['pip']}               # (Python installer)\n"
            if e.name in package_name.keys() else
            f"    (Are you sure that that module is installed on your system?)"
        ), file = stderr)
        raise SystemExit(10)

#[eof]
